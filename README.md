# Metric Based Grid Adaptation Using SU2 And NASA/Refine
This repository contains the flow simulation results, meshes, configuration files, and certain small codes written in C++ for postprocessing.

## Get Started
Install the [SU2 package](https://su2code.github.io/) to solve flow simulations and [NASA/Refine](https://github.com/nasa/refine) to run the adaptation cycles.
General recommendation is to install SU2 and refine from source with MPI support (provided by openmpi or [MPICH](https://www.mpich.org/)). Packages have a long dependency list so make sure you read the instructions provided on their documentation/manpages carefully.

## Using SU2
Once installed, using SU2 is really easy. Start with running a couple of test cases and get a hold of the configuration options. An exhaustive list (it is really, really long) of available configuration options are listed with a brief description in the [config_template.cfg](https://github.com/su2code/SU2/blob/master/config_template.cfg) file. Not all configuration options need to be explored, find the relevant ones in your specific [testcases folder](https://github.com/su2code/TestCases) with relevant *.su2 grid files and start getting familiar with the usage.
Run SU2 from the terminal using the command
```
$ SU2_CFD config_filename.cfg
```
for serial processing and
```
$ mpirun -n $NP SU2_CFD config_filename.cfg
```
for parallel processing. `$NP` is the number of processes (threads) you wish to run. It should ideally not exceed the total number of processors and should be a multiple of 2.

It is also recommended to set the **OUTPUT_FILES** variable to output **RESTART_ASCII** instead of **RESTART** (which is in binary format) in order to post-process the solution.

## Post Processing The SU2 Output Files
The repository has a C++ code that can be used to postprocess the output file generated by SU2. The default setting is for a 3D simulation for inviscid compressible flows. If your case matches the default setting just compile `getScalarSolutionFiles.cpp` without any extra flags using g++
```
$ g++ getScalarSolutionFiles.cpp -o OutputFileName
```
and run the binary output. Please note that you need to know the number of points in the mesh (and hence the solution) since the code does not automatically find it for you and create a folder titled `sol` in the same directory. The number of points is one less than the number of lines in the **restart_flow.csv** output file. Use
```
$ wc -l restart_flow.csv
```
to find the total number of lines and subtract one from the output.

The same code can also be run for two extra cases:
1. A Viscous flow simulation
2. 2D flow simulation.

Specific macros can be defined while compiling the code to match your case. Use the macro `TWOD` for a 2D flow and `VISCOUS` for a Viscous flow simulation. To use both of them you can compile the program like so:
```
$ g++ getScalarSolutionFiles.cpp -DTWOD -DVISCOUS -o 2d_viscous_solutions
```

Running the generated binary will create 9 solution files (8 for 2D) in the `sol` folder which can be later used to create the metric field and further adapt the grid using NASA/Refine. In this project we have used Mach Number to generate the metric fields.

## Using NASA/Refine
Refine is a simple yet powerful tool which can be used to create metric fields, adapt grids, translate grids from one format to another, and much more. You need the following files to create a metric field and adapt a grid:
1. The mesh/grid file
2. The geometry file in EGADS format (to adapt a grid)
3. The solution field (to generate a metric field) or the metric field (to adapt a grid)

### Generating The Very First Grid Using An EGADS Geometry

One can start with a very basic and course grid that fits the geometry of model. Use the following command to generate the initial grid:
```
$ ref bootstrap geometry_title.egads
```
The program will generate several output files suffixed with the geometry file name (`geometry_title` in the current example). Look for `*-vol.meshb` file (`geometry_title-vol.meshb` in the current example) which can be translated to *.su2 format later on and used in the solver.

> NOTE: You can also use multiple mpi ranks for most refine tasks by replacing the command `ref` with the command `mpirun -n $NP refmpifull` where `$NP` is the number of processes (threads) you want to use


### Converting The Mesh To SU2 Format

SU2 has a mesh format of its own and cannot read a `*.meshb` file which makes it an important step for us to translate the volume mesh obtained from the step above to a usable format. Use the following command:
```
$ ref translate input-volume-mesh.meshb output-volume-mesh.su2
```

> NOTE: There is a good chance that you may need to edit the su2 grid file to some extent in order to use it since refine translates the grid and does not combine identical surfaces into the same marker (For example there may be three markers numbered 3, 4, and 5 which are all adiabetic walls). You can find out the number of markers by using the `grep` command like so:
 
> ```
> $ grep -i nmark gridfile.su2
> ```

> If the number is higher than what you have expected it to be, you may need to combine a few markers into one and edit the numbers accordingly. The su2 mesh format is explained in their documentation [here](https://su2code.github.io/docs_v7/Mesh-File/) and should be referred to before making any changes to the file.

> ***Taking a backup of the original grid file is highly recommended before any edits are made since any mistake in the grid file may render it useless.***

### Editing The SU2 Grid File

Open the su2 grid file in a text editor and find the string **MARKER_TAG** which will be followed by another string **MARKER_ELEMS**. These two strings will be followed by several lines which hold the boundary data. You need to merge the boundary data of all the markers that are of the same boundary condition and change **MARKER_ELEMS** to the total number of elements that the marker now has (sum of all the merged markers).

Change the **NMARK** number accordingly too and the new grid should be good to go. You can also change the name of **MARKER_TAG** if you wish to so that it can be identified easily. It is not important and can be skipped.

Example:

For a square grid used as an example in [mesh file docs](https://su2code.github.io/docs_v7/Mesh-File/) the marker definition looks like so:
```
NMARK= 4
MARKER_TAG= lower
MARKER_ELEMS= 2
3 0 1
3 1 2
MARKER_TAG= right
MARKER_ELEMS= 2
3 2 5
3 5 8
MARKER_TAG= upper
MARKER_ELEMS= 2
3 8 7
3 7 6
MARKER_TAG= left
MARKER_ELEMS= 2
3 6 3
3 3 0
```
Let us say we want to merge the `upper` and `lower` surfaces and name the new marker as `horizontal`. We may do so by adding the elements of `upper` to `lower`, changing the **MARKER_TAG** to `horizontal`, changing **MARKER_ELEMS** from 2 to 4, and finally changing **NMARK** from 4 to 3. The new marker definition will look like so:

```
NMARK= 3
MARKER_TAG= horizontal
MARKER_ELEMS= 4
3 0 1
3 1 2
3 8 7
3 7 6
MARKER_TAG= right
MARKER_ELEMS= 2
3 2 5
3 5 8
MARKER_TAG= left
MARKER_ELEMS= 2
3 6 3
3 3 0
```

### Generating A Metric Field

The first task after receiving the solution fields from the post-processing code is to generate a metric field. The metric field will dictate the placement of new points and refinement of features in the adaptation cycle. You need a solution field to generate a metric field using refine. We have used Mach Number in all our testcases as the solution field. The `ref multiscale` command can be used to generate the metric field like so:

```
$ ref multiscale inputmesh.meshb ./sol/mach.sol $COMPLEXITY output-metric.solb
```
where the `$COMPLEXITY` is approximately half the number of target points in the new grid. The generated metric field can then be used too adapt the existing grid.

> NOTE: The general recommendation is to use the same complexity for 5-7 grid adaptation cycles until the mesh stops changing much and then increase the complexity by a factor ranging from 1.5 to 2.0.

### Adapting The Grid

This is the final step of the adaptation cycle before you start pre-processing for the solver. Not much to do here, just use the metric field generated in the step above and the egads geometry to ensure the new points get placed onto the geometry surface to adapt the grid. The command is:

```
$ ref adapt input-mesh.meshb --egads geometry-file.egads -m metric-field.solb -x output-adapted-mesh.meshb
```

After the adapted grid is generated you can convert it to SU2 format using the translate command discussed earlier. Check the su2 mesh file for any required changes. If it does, head over to [Editing the SU2 Grid File](#editing-the-su2-grid-file) and implement those changes. After that you are good to go.

## Testcase Results - Transonic Flow Over NACA0012 [2D]
Flow Conditions:
| Physical Quantity      | Value     |
| ---------------------- | --------- |
| Mach Number            | 0.8       |
| Angle of Attack        | 1.25      |
| Freestream Pressure    | 101325    |
| Freestream Temperature | 288.15    |
### Grid Refinement
|  |  |
| ---- | ---- |
| ![Grid 0](/naca0012/Transonic/naca0012_00/Images%20and%20Plots/Grid_00.png) | ![Grid 1](/naca0012/Transonic/naca0012_01/Images%20and%20Plots/Grid_01.png) |
| ![Grid 2](/naca0012/Transonic/naca0012_02/Images%20and%20Plots/Grid_02.png) | ![Grid 3](/naca0012/Transonic/naca0012_03/Images%20and%20Plots/Grid_03.png) |
| ![Grid 4](/naca0012/Transonic/naca0012_04/Images%20and%20Plots/Grid_04.png) | ![Grid 5](/naca0012/Transonic/naca0012_05/Images%20and%20Plots/Grid_05.png)

### Pressure Fields
|  |  |
| ----: | :---- |
| ![Pressure 0](/naca0012/Transonic/naca0012_00/Images%20and%20Plots/Pressure_00.png) | ![Pressure 1](/naca0012/Transonic/naca0012_01/Images%20and%20Plots/Pressure_01.png) |
| ![Pressure 2](/naca0012/Transonic/naca0012_02/Images%20and%20Plots/Pressure_02.png) | ![Pressure 3](/naca0012/Transonic/naca0012_03/Images%20and%20Plots/Pressure_03.png) |
| ![Pressure 4](/naca0012/Transonic/naca0012_04/Images%20and%20Plots/Pressure_04.png) | ![Pressure 5](/naca0012/Transonic/naca0012_05/Images%20and%20Plots/Pressure_05.png)